package com.example.c1;

import javax.sql.rowset.CachedRowSet;
import javax.sql.rowset.RowSetProvider;
import java.sql.*;

public class SQLiteDBConnect {
    private final String dbPath;
    private Connection connection;

    public SQLiteDBConnect(String dbPath) {
        this.dbPath = dbPath;
    }

    public void connect() throws SQLException {
        try {
            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection("jdbc:sqlite:" + dbPath);
            initializeDatabase();
        } catch (ClassNotFoundException e) {
            throw new SQLException("SQLite driver not found", e);
        }
    }

    private void initializeDatabase() throws SQLException {
        // Создаем таблицы, если они не существуют
        executeUpdate("CREATE TABLE IF NOT EXISTS genres (" +
                "id INTEGER PRIMARY KEY, " +
                "name TEXT NOT NULL)");

        executeUpdate("CREATE TABLE IF NOT EXISTS directors (" +
                "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "name TEXT NOT NULL)");

        executeUpdate("CREATE TABLE IF NOT EXISTS movies (" +
                "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "title TEXT NOT NULL, " +
                "original_title TEXT NOT NULL, " +
                "year INTEGER NOT NULL, " +
                "imdb_rating REAL, " +
                "views INTEGER DEFAULT 0, " +
                "director_id INTEGER, " +
                "genre_id INTEGER, " +
                "FOREIGN KEY (director_id) REFERENCES directors(id), " +
                "FOREIGN KEY (genre_id) REFERENCES genres(id))");

        // Заполняем начальными данными
        fillInitialData();
    }

    private void fillInitialData() throws SQLException {
        // Проверяем, есть ли уже данные
        try (ResultSet rs = executeQuery("SELECT COUNT(*) FROM genres")) {
            if (rs.next() && rs.getInt(1) == 0) {
                // Заполняем жанры
                executeUpdate("INSERT INTO genres VALUES (1, 'Action')");
                executeUpdate("INSERT INTO genres VALUES (2, 'Comedy')");
                executeUpdate("INSERT INTO genres VALUES (3, 'Drama')");
                executeUpdate("INSERT INTO genres VALUES (4, 'Sci-Fi')");
                executeUpdate("INSERT INTO genres VALUES (5, 'Thriller')");

                // Заполняем режиссеров
                executeUpdate("INSERT INTO directors (name) VALUES ('Christopher Nolan')");
                executeUpdate("INSERT INTO directors (name) VALUES ('Quentin Tarantino')");
                executeUpdate("INSERT INTO directors (name) VALUES ('Steven Spielberg')");
                executeUpdate("INSERT INTO directors (name) VALUES ('James Cameron')");
                executeUpdate("INSERT INTO directors (name) VALUES ('Martin Scorsese')");

                // Добавляем несколько фильмов
                executeUpdate("INSERT INTO movies (title, original_title, year, " +
                        "imdb_rating, views, director_id, genre_id) VALUES " +
                        "('Inception', 'Inception', 2010, 8.8, 100, 1, 4)");

                executeUpdate("INSERT INTO movies (title, original_title, year, " +
                        "imdb_rating, views, director_id, genre_id) VALUES " +
                        "('The Dark Knight', 'The Dark Knight', 2008, 9.0, 150, 1, 1)");

                executeUpdate("INSERT INTO movies (title, original_title, year, " +
                        "imdb_rating, views, director_id, genre_id) VALUES " +
                        "('The Dark Knight', 'The Dark Knight', 2008, 9.0, 150, 1, 1)");
            }
        }
    }

    public CachedRowSet executeQuery(String query) throws SQLException {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet();
            crs.populate(rs);
            return crs;
        }
    }

    public int executeUpdate(String sql) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            return stmt.executeUpdate(sql);
        }
    }

    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return connection.prepareStatement(sql);
    }

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return connection.prepareStatement(sql, autoGeneratedKeys);
    }

    public void disconnect() {
        try {
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            System.err.println("Error closing connection: " + e.getMessage());
        }
    }

    public Connection getConnection() {
        return connection;
    }

    public String getDbPath() {
        return dbPath;
    }
}